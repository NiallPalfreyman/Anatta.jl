#========================================================================================#
#	Laboratory 603
#
# Non-Computability.
#
# Author: Niall Palfreyman, February 2025.
#========================================================================================#
[
    Activity(
        """
        Hi! Welcome to Anatta Subject 603:
            Non-Computability - An important aspect of irreducible behaviour is unpredictability.

        Reduction is the idea that we can understand system-level behaviours by reducing them to
        individual component behaviours, yet we demonstrated in the previous lab that this is not
        always possible. We cannot reduce the oscillations of the Ecosystem model to the behaviour
        of individual agents, simply because this oscillatory behaviour is Collective: it is
        generated by the entire system. Nevertheless, reductionists may still argue that we can
        reduce these oscillations to the structure of relationships Between individual agents.

        This reductive argument assumes that we can always us computation to predict the effects of
        agents' relationships and behaviours. However, there exists a whole class of patterns that
        we can generate, yet can Never predict using computation. In this lab, we will demonstrate
        this important property of Non-Computability ...
        """,
        "",
        x -> true
    ),
    Activity(
        """
        In this lab, we will discover that non-computable patterns are not necessarily collective,
        for we will generate a non-computable pattern using a very simple system containing just one
        single Grasshopper agent that jumps around space according to a very simple set of rules.
        This single agent's behaviour will reliably generate an easily recognisable pattern, yet we
        shall see that we could not predict that pattern simply from knowing the agent's behavioural
        rule!. This unpredictability show us the limits of structural computability.

        Include the file Computability.jl. At each step of Computability.demo(), the single
        Grasshopper agent (the green dot) randomly chooses one of the four available food sources
        (blue dots), then moves halfway towards that food source. Press the Step button several
        times to watch the agent jumping around. Wherever it lands, it leaves behind a tiny (1pt)
        red footprint. Keep stepping the agent until you get a feel for the pattern that these
        footprints are building. What words might you use to describe this structure???
        """,
        "If you're unsure, press the Run button; stop the simulation by pressing Run again",
        x -> any(map(y->occursin(y,lowercase(x)),["uniform","square","random"]))
    ),
    Activity(
        """
        The Grasshopper's footprints are building a very ordinary-looking square of randomly
        distributed points. This is a very simple pattern, and we can easily predict it from the
        Grasshopper's simple rule. But now use the appropriate slider to change the value of the
        parameter n_sources from 4 to 3, then press the Reset button in the playground console.
        
        Notice that there are now only three food sources - otherwise, nothing much has changed.
        Press the Step button up to about 50 times, and after each step ask yourself: Are there any
        parts of the spatial area between the food sources that the Grasshopper Never visits? If
        so, where are they?
        """,
        "Please do Not yet press the Run button!",
        x -> any(map(y->occursin(y,lowercase(x)),["centre","center","middle"]))
    ),
    Activity(
        """
        Now you have some idea of the structure of this pattern, press the Run button to watch it
        being generated at speed. You might also like to use the sliders "dt" and "spu" to make
        things go a little faster. What is the name of this pattern?
        """,
        "A small hint: It's a triangle named after a famous Polish mathematician",
        x -> occursin("sierp",lowercase(x))
    ),
    Activity(
        """
        Use all sliders Except the n_sources and r sliders to experiment with the Sierpinski
        triangle. Get a feel for just how amazingly stable and complex this pattern is.

        Now think about the following question: How would you describe the structure of the
        Sierpinski triangle to someone? Describe in detail to a partner exactly how you would go
        about constructing the triangle on a sheet of paper.
        """,
        "Try thinking about which parts you might erase from an initially solid red triangle",
        x -> all(map(y->occursin(y,lowercase(x)),["triangle","middle"]))
    ),
    Activity(
        """
        Experiment with the various sliders, changing the number of particles, vertices and the
        contraction factor r. What exactly does r do? Study the method agent_step!() to answer the
        question: Which aspect of the particle's movement does r influence?
        """,
        "", 
        x -> occursin("distance",lowercase(x))
    ),
    Activity(
        """
        I now have some questions about the patterns you have been generating. Reset r=0.5 and
        n_sources=3 again to recover the original pattern, maximise the playground window
        and generate lots of points to see the pattern in great detail.

        Now consider first the point in the centre of the pattern. Do you think the Grasshoppers
        can ever in principle visit this point?
        """,
        "", 
        x -> occursin("no",lowercase(x))
    ),
    Activity(
        """
        How long do you think it would take to prove your answer to the previous activity?
        """,
        "", 
        x -> any(map(y->occursin(y,lowercase(x)),["forever","infinit"]))
    ),
    Activity(
        """
        Now focus your attention on one of the tiniest triangles in your pattern, and pick a point
        at the centre of this tiny triangle. Do you think the Grasshoppers can ever in principle
        visit this point?
        """,
        "", 
        x -> occursin("no",lowercase(x))
    ),
    Activity(
        """
        Do you think it would take longer, shorter or the same length of time to prove your answer
        for the tiny triangle, than it would take to prove your previous answer for the point at the
        centre of the whole pattern?
        """,
        "Think: How long will it take before you are Absolutely Certain?",
        x -> occursin("same",lowercase(x))
    ),
    Activity(
        """
        Now focus your attention on one of the dark areas between the triangles in your pattern.
        Imagine an arbitrary point somewhere within that dark area. Do you think the Grasshoppers
        can ever in principle visit that point?
        """,
        "", 
        x -> occursin("dunno",lowercase(x)) || occursin("know",lowercase(x))
    ),
    Activity(
        """
        How long do you think it might take a computer to verify your previous answer?
        """,
        "", 
        x -> occursin("infinit",lowercase(x))
    ),
    Activity(
        """
        The Sierpinski triangle is a fractal figure that displays Self-Similarity at every scale.
        That is, no matter how far we zoom into any part of the fractal, we will keep seeing the
        same triangular pattern repeat itself indefinitely. And now comes the amazing thing:

        Although this self-similarity is intuitively obvious to us, this is not something that we
        can compututationally prove for every possible zoom level!

        Think about what this means. You and I both Know that the Sierpinski triangle has the same
        nested triangular structure all the way down, but we cannot compute it. The Grasshoppers'
        motion generates a structural pattern that suggests certain properties like whether or not
        any given point lies inside that pattern. Yet it can take an infinitely long time for a
        computer to verify that suggestion!

        Here is the crucial difference: Whereas you and I see an infinite sequence of nested
        triangles, a computer sees only a set of points with different distances between them.
        Clearly, we organisms are doing something differently from a computer!
        """,
        "", 
        x -> true
    ),
    Activity(
        """
        Before proceeding further with this lab, I want to draw your attention to a small coding
        issue. Look at the graphics code in Computability.demo(). After setting up the playground,
        we want to superimpose onto the basic ABM Observable abmobs all the footprints of each
        agent in the model. To achieve this, we use the method lift() to add a listener to abmobs,
        so that every time abmobs changes (for example, after each call to model_step!()), we can
        plot the new Grasshopper footprints.

        What is the name of the other variable that is plotted in exactly the same way?
        """,
        "",
        x -> occursin("sources",lowercase(x))
    ),
    Activity(
        """
        Now we look at non-computability in a more complex context. You will create a new model
        that generates a biologically motivated non-computable pattern. Before you do this, we need
        to interpret the Grasshopper's movement rule from a more geometrical perspective. We can
        think of the rule "Move halfway towards a random food source" as an Affine Transformation
        of the Grasshopper's current position P with respect to a random food source location S:
            f(P) = (P+S)/2 = [0.5 0.0] * P + S/2 = A*P + S/2.
                             [0.0 0.5]

        This affine transformation consists of a linear transformation A of the Grasshopper's
        position P, followed by a translation along the vector S/2. Affine transformations are
        linear transformations combined with translations, and are used widely in computer
        graphics. Writing the Sierpinski rule in this way, we see that we can generalise the rule
        by simply varying the values of the individual elements of the linear transformation
        matrix A and the translation vector S. So let's program this for ourselves ... :)
        """,
        "",
        x -> true
    ),
    Activity(
        """
        Copy the file NonComputability.jl to a new file Leafy.jl, then modify its code to construct
        a new non-computable pattern through the movement of Builder agents. Create a 2-D continuous
        world with extent 15x15, define a model property :base_point describing a point halfway
        along the horizontal axis, and initialise all Builder agents in the Leafy model to this
        base_point location.

        Now test your changes by running Leafy.demo(). What pattern should this run produce?
        """,
        "",
        x -> occursin("sierp",lowercase(x))
    ),
    Activity(
        """
        Next, define a model property 'affine' which is a Vector of functions modelling the
        following four affine transformations:
        f[1](P) = [0 0; 0 0.16] * P + [0,0]
        f[2](P) = [0.85 0.04; -0.04 0.85] * P + [0,1.6]
        f[3](P) = [0.20 -0.26; 0.23 0.22] * P + [0,1.6]
        f[4](P) = [-0.15 0.28; 0.26 0.24] * P + [0,0.44]

        Test your affine transformations by replacing the contents of agent_step!() by the
        following code:
            p = collect(builder.pos) - model.base_point
            p = rand(model.affine)(p)
            move_agent!( builder, Tuple(p+model.base_point), model)

        The reference mode for your current changes is the module name Leafy. What kind of leaf do
        the graphical footprints remind you of?
        """,
        "The leaf contains pinas and pinules! :)",
        x -> occursin("fern",lowercase(x))
    ),
    Activity(
        """
        Finally, modify the method Leafy.agent_step!() to implement the following movement rule for
        Builders: At each step, the Builder moves as shown below with the associated probabilities,
        where p is the Builder's current position vector _relative_ to model.base_point:
                - 1%:	p -> affine[1](p);
                - 85%:	p -> affine[2](p);
                - 7%:	p -> affine[3](p);
                - 7%:	p -> affine[4](p).

        Reference mode: If you run Leafy.demo(), you will see how changing the the distribution of
        these affine transformations changes the pattern generated by the Builders.
        """,
        "",
        x -> true
    ),
    Activity(
        """
        When you are satisfied that your program correctly fulfils its reference mode, investigate
        the 'magic parameters' in the generating procedure by setting up sliders to change their
        values. Discuss with your partners the meaning of the various parameters for the developing
        leaf pattern. In particular, we can change the bend of the fern from right to left by
        changing the values of matrix elements in one of the affine transformations. Which affine
        transformation should we change to achieve this?
        """,
        "Give me the number of the relevant transformation in your affine vector", 
        x -> parse(Int,x) == 2
    ),
    Activity(
        """
        Congratulations! Notice the following point about your Leafy program: you can easily check
        whether your program is working correctly, by simply looking to see whether it generates a
        leaf-like pattern. I have not drawn you a leaf or told you what the leaf should look like,
        but you immediately know when your program works because it produces a leaf-like pattern.
        We call this way of checking program correctness against a reference pattern "structure-
        referenced modelling". The general idea is this:

        The reference modes of generative modelling are pattern structures. While studying complex
        systems in nature, we observe certain structural patterns, and use generative modelling to
        investigate how these patterns arise: we construct a plausible agent-based model and study
        its behaviour. We measure the quality of our model by checking whether these behaviours
        collectively generate the observed structural reference patterns.

        Which structure formed the reference mode of Schelling's model?
        """,
        "", 
        x -> occursin("segreg",lowercase(x))
    ),
    Activity(
        """
        Non-computability is a perfect example of the Incompleteness Theorem proven by Kurt GÃ¶del
        in 1931. GÃ¶del showed that mathematical logic is Incomplete in the sense that there exist
        mathematical truths that we can never prove, but must simply decide for ourselves. Take for
        example Goldbach's conjecture that every even number can be expressed as the sum of two
        prime numbers. We cannot prove this, but we can define it as an axiom of Number Theory.
        In fact, Gregory Chaitin has since proven that there are infinitely more Unprovable truths
        than Provable ones!

        Similarly, we have discovered in this lab that computation is incomplete in the sense that
        there are certain geometrical figures whose properties we can never compute, but must
        decide for ourselves - like for example whether any given point in the plane is, or is not,
        contained in your fern. We cannot compute this, but we can state it as a proposition that
        we then confirm or disconfirm by experiment, or simply assert as an axiom by making it the
        starting point of the Builder agents.

        And that will be our goal in this course: We shall use ABM to discover how biological
        organisms generate the structures underlying life and meaning. We have good reason to
        suspect that these structures are non-computable, but maybe we can use generative modelling
        to help us guess the biological dynamics out of which these structures arise ...
        """,
        "", 
        x -> true
    ),
]