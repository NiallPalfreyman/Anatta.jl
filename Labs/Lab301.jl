#========================================================================================#
#	Laboratory 301: Handling ABM output
#
# Author:  Niall Palfreyman, 1/1/2025.
#========================================================================================#
[
    Activity(
        """
        Hi - Welcome to Anatta Lab 301!
            Emergence: Behaviour generated by interactions between individuals can be surprising.

        In the previous lab, we used Generative Science (GS) to construct Schelling's Segregation
        Model. In Schelling.jl, we arranged for Person agents to relocate within a community if
        they felt uncomfortable, where comfort was based on whether the proportion of neighbours
        belonging to the same tribe (0/1) as the agent was higher than a certain preference value.

        In order to confirm Schelling's research hypothesis about segregation in communities, we
        want to construct an experiment that Contradicts the following null hypothesis:
            H0: The segregation level in a community Decreases or stays the same when agents'
                comfort level Decreases - that is, when we raise their preference.

        To contradict H0, we must demonstrate that raising preference strictly Increases
        the level of segregation in a community. In this lab, we use our newly developed Schelling
        module to confirm Schelling's research hypothesis, and on the way we will learn more about
        how to analyse and visualise ABM output data. Enjoy! :)
        """,
        "For you to think about: Why do we contradict H0, rather than try to prove H1?",
        x -> true
    ),
    Activity(
        """
        We have already implemented a way in which users can raise and lower preference
        using the single argument of demo(). For example, the call Schelling.demo(0.5) runs our
        simulation with a preference value of 0.5, so that agents require only 50% of their
        neighbours to be of the same tribe as themselves in order to feel comfortable.

        Run demo() with a variety of preference values and notice the effect it has on the
        column sum_comfort of your output. Which leads to faster growth of sum_comfort: high or low
        values of preference?
        """,
        "Can you think why this should be the case?",
        x -> occursin("low",lowercase(x))
    ),
    Activity(
        """
        Our next task is to implement a way of defining and measuring the segregation level in the
        community that develops during our simulation. In fact, come to think of it: Are we even
        certain that segregation is currently occurring in our simulation? How do we measure
        segregation?

        Segregation is the extent to which agents gather into separate tribe-groups, so when they
        are segregated, the two tribes will be in spatially separate areas. Within the two
        dimensions of our ABM world, this separation can be spatially quite complex, but we might
        still be able to measure segregation to a first approximation using the average x-position
        of the two tribal groups.

        What do you expect the mean position of agents in each tribe to be at the beginning of our
        experiment - after we have placed them randomly in the world? Do you expect these two
        respective tribal means to be the same as each other, or different?
        """,
        "",
        x -> occursin("same",lowercase(x)) || occursin("equal",lowercase(x))
    ),
    Activity(
        """
        Now suppose that the tribes have segregated. Clearly, the respective positions of the two
        tribal groups will then be different from each other, but that doesn't necessarily mean
        that their mean positions will differ. Can you think of an arrangement of segregated groups
        in which the mean positions of the two tribal groups are identical?
        """,
        "Configurations with identical mean tribal positions are, for example, tribes\n" *
        "arranged in concentric circles or in symmetrically positioned compact groups.",
        x -> (hint();true)
    ),
    Activity(
        """
        So, you see that it is certainly possible for segregated groups of agents to have identical
        mean positions, but those are special arrangements that will not occur very often. So one
        simple way for us to get a feel for the segration level in our simulation is to inspect the
        mean x-position of each of the two tribes.

        Find the "To-do" activity "tribe position" in demo(). The vector `adata` in the next line
        specifies the agent-data that we want to collect and return from the call to run!() lower
        down. At present, we collect only one column of data: the sum of comfort values for all
        agents. Now we will add two more columns to our output!

        The data specifications are tuples: the first element specifies the agent data to be
        collected, and the second element specifies the way in which this agent data is combined.
        Extend the current adata specification to match the following, then tell me which value you
        see in the final column of your data output:
            adata = [(:comfort, sum), (ag->ag.pos[1], maximum)]
        """,
        "What do you expect to be the maximum x-position of agents in the ABM world?",
        x -> x==60
    ),
    Activity(
        """
        The first data-spec element can be either an agent field (agent.comfort) or a data-
        collection function that can be applied to an agent (ag -> ag.pos[1]). As you see, the
        problem with using an implicit function like this is that it gives run!() no convenient
        name to use as a column header. We can solve this problem by naming the data-collection
        function ourselves:
            xpos(agent) = agent.pos[1]
            adata = [(:comfort, sum), (xpos, maximum)]

        What name is assigned to your final output column when you make this change?
        """,
        "",
        x -> x=="maximum_xpos"
    ),
    Activity(
        """
        To display the mean x-positions of the two tribes, we need to define two data-collection
        functions tribe_0_x(agent) and tribe_1_x(agent), and one data-combining function
        partial_mean(data). tribe_0_x(agent) returns agent.pos[1] Only for the tribe_0 agents;
        otherwise, it returns 0. tribe_1_x(agent) does the same for the tribe_1 agents. The
        function partial_mean(data) returns the mean of all Nonzero elements of the data vector.
        
        Implement these functions now in demo(), register them in adata, then run demo() with a
        preference value of 0.0. Do you observe any segregation?
        """,
        "Remember: segregation would display itself as a difference in mean tribal x-position",
        x -> occursin('n',lowercase(x))
    ),
    Activity(
        """
        So. 9 generations of the Schelling model produce no visible segregation using a comfort
        threshold of 0.0. But of course, this model is stochastic: the results might vary between
        runs. So let's just check this: change the number of steps in run!() from 9 to 99, then
        perform several consecutive runs. Do you observe any segregation now?
        """,
        "",
        x -> occursin('n',lowercase(x))
    ),
    Activity(
        """
        You've probably realised by now that we wouldn't expect any segregation using a preference
        of zero. All agents are comfortable with all neighbourhood situations, and so
        remain at their original position, leaving the initial segregation level unchanged.

        On the other hand, when we increase preference to 1.0, agents are never comfortable,
        and so bounce around all over, giving both tribes a mean position at the approximate centre
        (x~30) of the world.

        Now try a run of 99 generations using preference=0.7. Do you observe segregation?
        """,
        "Remember: segregation manifests as a Reliable difference in mean tribal x-position",
        x -> occursin('y',lowercase(x))
    ),
    Activity(
        """
        This is Good News! As we raise the preference from 0.0-0.7, the discrepancy in mean
        tribal x-position - and hence the level of segregation - increases reliably. Notice that it
        sometimes becomes quite small, when the tribes segregate along the y-, rather than the
        x-axis, but our results so far definitely seem to contradict the null hypothesis that
        raising the preference level should Decrease segregation (or leave it unchanged).

        Give yourself a big pat on the back! :D
        """,
        "",
        x -> true
    ),
    Activity(
        """
        All looks good, however the mean tribal x-position is only a very approximate measure of
        segregation, and we still don't really know what segregation looks like in our model. To
        gain a better understanding of what's going on, we will generate some graphical output
        using the abmvideo() method. Make the following code changes, then compile, run and enjoy
        the mp4 file that will be saved into your current directory!
        
        Append GLMakie to the using statement under the "To-do" activity "graphics backend", then
        insert the following code under the "To-do" activity "generate video":
            tribecolor(agent) = agent.tribe==1 ? :blue : :orange
            tribemarker(agent) = agent.tribe==1 ? :circle : :rect
            abmvideo( "schelling.mp4", schelling(preference);
                title = "Segregation model (comfort threshold \$preference)",
                agent_size=10, agent_color=tribecolor, agent_marker=tribemarker,
                framerate = 4, frames = 50
            )
        """,
        "",
        x -> true
    ),
    Activity(
        """
        Do you see how our video makes sense of our earlier observation that the differences in the
        mean tribal x-position were only very small? The video shows us clearly that segregation is
        happening in our simulation, but the segregated regions of the two tribes are so closely
        intertwined with each other that their mean x-positions might easily be almost equal.

        This video makes it clear that if we wish to analyse how segregation arises from varying
        values of comfort threshold, then we really need to explore a Visual representation of the
        Schelling model. The method abmplayground() provided in the AgentTools module offers us
        exactly this possibility. `include()` the file AgentTools.jl in the Generative folder and
        `using` the module .AgentTools. Now insert the following lines of code under the "To-do"
        activity "create an exploratory playground", and reply() to move on to the next activity:
            playground, _ = abmplayground( schelling;
                agent_size = 10, agent_color = tribecolor, agent_marker = tribemarker,
                params = Dict( :preference => 0.0:0.01:1.0)
            )
            display(playground)
        """,
        "",
        x -> true
    ),
    Activity(
        """
        Look carefully at the code you have just entered. The second return value of abmplayground()
        provides Observable access to the playground, and will be of interest to us in the next lab.
        For now, we are more interested in the first return value (playground), which is a graphics
        application that provides a visual console onto the Schelling model. The first argument of
        our call to abmplayground() is the model initialisation function schelling() that we wrote
        above. The `params` Dictionary specifies the Independent Variables of our experiment that
        we wish to vary during our experiment. In our case, we wish to vary independently the value
        of preference between 0.0 and 1.0 (in steps of 0.1), in order to explore how this affects
        the Dependent Variable of segregation.

        Compile and run the new demo() method. Play with the interface to discover how to use the
        controls, then explore the effect of various values of preference. Use your playgroung to
        answer this question:
            Does our Segregation Model contradict our null hypothesis H0 by showing that the level
            of segregation (broadly) increases with higher values of preference?
        """,
        "",
        x -> occursin('y',lowercase(x))
    ),
    Activity(
        """
        It seems clear from our investigation that individual personal preference drives
        segregation of communities, and a surprising aspect of our results is just how small that
        preference needs to be, in order for it to generate segregation. Now we want to communicate
        this insight to others who do not yet possess the understanding of population dynamics that
        we have developed through investigating Schelling's model.

        The method present_insight() presents Schelling's insight in a simple graph. In this
        method, we define an agent as segregated if all of its neighbours belong to the same tribe
        as the agent itself. We then define the segregation of a community as the proportion of its
        agents that are segregated. Under the "To-do" activity counting "tribally similar
        neighbours", implement the counting algorithm that defines this segregation value.

        Does the segregation level rise uniformly from zero to its maximum with rising preference?
        """,
        "",
        x -> occursin('n',lowercase(x))
    ),
    Activity(
        """
        Your rising curve from present_insight() contains occasional flat plateaus, where the rise
        in community segregation with individual preference gets 'stuck' because agents are unable
        to move freely enough to increase their segregation. Biological evolution has found a
        powerful way of escaping from Suboptimal plateaus of organism development: random mutation.
        Random mutations of DNA cause the developmental processes of organisms to drift randomly
        over time - occasionally discover more effective ways of coping with their environment.
        
        Apply randomness to the Schelling model to escape from the plateaus in your segregation-
        preference curve. In the method agent_step!(), under the "To-do" activity "jump to a
        random empty grid location", extend the if-condition to include a probability of 0.01 that
        an agent will occasionally spontaneously jump to a random location, even though it is
        already comfortable.
        
        When you have implemented and run this idea, study your new, improved segregation-
        preference graph, and tell me at which level of individual preference the community
        segregation level first exceeds 1/20 of the population?
        """,
        "",
        x -> x < 0.3
    ),
    Activity(
        """
        Your answer from the previous activity is actually quite shocking. Individuals who prefer
        jus 30% (less than 1/3) of their neighbours to belong to their own tribe pull the community
        toward a segregation level of 1/20! Now, 30% is not very extreme; it corresponds to black,
        white or asian citizens preferring just 3 out of every 10 of their neighbours to come from
        the same ethnic background. It corresponds to women preferring just 3 out of every 10 people
        at their workplace to be female. Yet this preference (not requirement!) drives communities
        to a point where 1 in 20 citizens are Entirely surrounded in their social or work
        environment by citizens of similar skin-colour, ethnicity or gender.

        This was the big surprise of Schelling's work in the early 1970's: it showed that promoting
        cultural plurality is not simply an issue of urban planning, but also an issue of educating
        people's personal preferences. This lesson is just as relevant today as it was then.
        """,
        "",
        x -> x <= 0.3
    ),
]
